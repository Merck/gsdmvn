---
title: "`gridpts`, `h1` and `hupdate` in Rcpp"
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(gsdmvn)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(bench)
library(microbenchmark)
devtools::load_all()
```

# Profile `gs_power_npe`

```{r functions}
n_iter <- 100
prof_gs_power_npe <- function(times = rep(0, 6), n_iter = 100,
    theta = .1, theta1 = NULL, info = 1, info1 = NULL, info0 = NULL,
                         binding = FALSE,
                         upper=gs_b, lower=gs_b, upar = qnorm(.975), lpar= -Inf,
                         test_upper = TRUE, test_lower = TRUE,
                         r = 18, tol = 1e-6){
  #######################################################################################
  # WRITE INPUT CHECK TESTS AND RETURN APPROPRIATE ERROR MESSAGES
  # theta should be a scalar or vector of real values; if vector, same length as info
  # info should be a scalar or vector of positive increasing values
  # info0 should be NULL or of the same form as info
  # test_upper and test_lower should be logical scalar or vector; if vector same length as info
  # END INPUT CHECKS
  #######################################################################################
  
for (itr in 1:n_iter) {
  # SET UP PARAMETERS
  #############Timer1############
  start1 <- Sys.time()

  K <- length(info)
  if (is.null(info0)) info0 <- info
  if (is.null(info1)) info1 <- info
  if (length(info1) != length(info) || length(info0) != length(info)) stop("gs_power_npe: length of info, info0, info1 must be the same")
  if (length(theta) == 1 && K > 1) theta <- rep(theta, K)
  if (is.null(theta1)){theta1 <- theta}else if (length(theta1)==1) theta1 <- rep(theta1,K)
  if (length(test_upper) == 1 && K > 1) test_upper <- rep(test_upper, K)
  if (length(test_lower) == 1 && K > 1) test_lower <- rep(test_lower, K)
  a <- rep(-Inf, K)
  b <- rep(Inf, K)
  hgm1_0 <- NULL
  hgm1_1 <- NULL
  hgm1 <- NULL
  upperProb <- rep(NA, K)
  lowerProb <- rep(NA, K)
  
  times[1] <- times[1] + difftime(Sys.time(), start1, units = "sec")[[1]]
  ######################################################################################
  # COMPUTE BOUNDS
  for(k in 1:K){
    #############Timer2############
    start2 <- Sys.time()
    
    # Lower bound update
    a[k] <- lower(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                  efficacy = FALSE)
    # Upper bound update
    b[k] <- upper(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
    
    times[2] <- times[2] + difftime(Sys.time(), start2, units = "sec")[[1]]
    ##############################
    if(k==1){
      #############Timer3############
      start3 <- Sys.time()
      
      upperProb[1] <- if(b[1] < Inf) {pnorm(b[1], mean = sqrt(info[1]) * theta[1], lower.tail = FALSE)}else{0}
      lowerProb[1] <- if(a[1] > -Inf){pnorm(a[1], mean = sqrt(info[1]) * theta[1])}else{0}

      times[3] <- times[3] + difftime(Sys.time(), start3, units = "sec")[[1]]
      #############Timer4###########
      start4 <- Sys.time()

      hgm1_0 <- h1(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- h1(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- h1(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
      
      times[4] <- times[4] + difftime(Sys.time(), start4, units = "sec")[[1]]
      ##############################
    }else{
      #############Timer5############
      start5 <- Sys.time()

      # Cross upper bound
      upperProb[k] <- if(b[k]< Inf){
        hupdate(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      # Cross lower bound
      lowerProb[k] <- if(a[k] > -Inf){
        hupdate(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      if(k < K){
        hgm1_0 <- hupdate(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                          thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
        hgm1_1 <- hupdate(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                          thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
        hgm1   <- hupdate(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                          thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
      }
      times[5] <- times[5] + difftime(Sys.time(), start5, units = "sec")[[1]]
    }
  }
  
  ######################################################################################
  # RETURN A TIBBLE
  #############Timer6############
  start6 <- Sys.time()

  tibble::tibble(
    Analysis = rep(1:K, 2),
    Bound = c(rep("Upper", K), rep("Lower", K)),
    Z= c(b, a),
    Probability = c(cumsum(upperProb),
                    cumsum(lowerProb)),
    theta = rep(theta, 2),
    theta1 = rep(theta1, 2),
    info = rep(info, 2),
    info0 = rep(info0, 2),
    info1 = rep(info1, 2))
  times[6] <- times[6] + difftime(Sys.time(), start6, units = "sec")[[1]]
  
}
  tb <- data.frame(eval = c("Set up parameters", "Compute bounds", "Compute probs",
                            "h1", "hupdate", "Create a tibble",
                            "All"),
                   time = round(c(times / n_iter, sum(times) / n_iter), 6),
                   percent = c(round(times / sum(times) * 100, 2), 100))
  names(tb) <- c("eval", "runtime in sec", "%")
  return (tb)
}
```

## Example 1: Single analysis with type I error controlled

### Runtime (in second)
```{r ex1_runtime}
time1 <- 0
for (i in 1:n_iter) {
  start <- Sys.time()
  gs_power_npe(theta = 0) 
  time1 = time1 + difftime(Sys.time(), start, units = "sec")[[1]]
}
rm(list = c("start"))

time1/n_iter
```

### Profile
```{r ex1_profile}
prof1 <- prof_gs_power_npe(theta = 0)
prof1 %>% gt()
```

## Example 2: Multiple analysis with fixed bound

### Runtime (in second)
```{r ex2_runtime}
time2 <- 0
for (i in 1:n_iter) {
  upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
  start <- Sys.time()
  gs_power_npe(theta = c(.1, .2, .3), 
             info = (1:3) * 40, 
             upper = gs_b, 
             upar = upar,
             lower = gs_b, 
             lpar = c(-1, 0, 0)) 
  time2 = time2 + difftime(Sys.time(), start, units = "sec")[[1]]
}
rm(list = c("upar", "start"))

time2/n_iter
```

### Profile
```{r ex2_profile}
upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
prof2 <- prof_gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = upar,
  lower = gs_b,
  lpar = c(-1, 0, 0))
rm(list = c("upar"))

prof2 %>% gt()
```

## Example 3: Multiple analysis with spending function bounds (2-sided asymmetric spend)

### Runtime (in second)
```{r ex3_runtime}
time3 <- 0
for (i in 1:n_iter) {
  upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
  lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

  start <- Sys.time()
  gs_power_npe(theta = c(.1, .2, .3), 
               info = (1:3) * 40,
               upper = gs_spending_bound,
               upar = upar,
               lower = gs_spending_bound,
               lpar = lpar)
  time3 = time3 + difftime(Sys.time(), start, units = "sec")[[1]]
}
rm(list = c("upar", "lpar", "start"))
time3/n_iter
```

### Profile
```{r ex3_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3 <- prof_gs_power_npe(
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)
rm(list = c("upar", "lpar"))

prof3 %>% gt()
```

### Same bounds, but power under different theta

#### Runtime (in second)
```{r ex31_runtime}
time3.1 <- 0
for (i in 1:n_iter) {
  upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
  lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

  start <- Sys.time()
  gs_power_npe(theta = c(.15, .25, .35), 
               theta1 = c(.1, .2, .3), 
               info = (1:3) * 40,
               upper = gs_spending_bound,
               upar = upar,
               lower = gs_spending_bound,
               lpar = lpar)
  time3.1 = time3.1 + difftime(Sys.time(), start, units = "sec")[[1]]
}
rm(list = c("upar", "lpar", "start"))
time3.1/n_iter
```

#### Profile
```{r ex31_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3.1 <- prof_gs_power_npe(
  theta = c(.15, .25, .35), 
  theta1 = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)
rm(list = c("upar", "lpar"))

prof3.1 %>% gt()
```


## Example 4: Multiple analysis with spending function bounds (2-sided symmetric spend)

### Runtime (in second)
```{r ex4_runtime}
time4 <- 0
for (i in 1:n_iter) {
  upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
  lpar <- upar
  start <- Sys.time()
  xx <- gs_power_npe(theta = rep(0, 3), 
                     theta1 = rep(0, 3), 
                     info = (1:3) * 40,
                     upper = gs_spending_bound,
                     binding = TRUE,
                     upar = upar,
                     lower = gs_spending_bound,
                     lpar = lpar)
  time4 = time4 + difftime(Sys.time(), start, units = "sec")[[1]]
}
time4/n_iter
```

### Profile
```{r ex4_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- upar

prof4 <- prof_gs_power_npe(
  theta = rep(0, 3), 
  theta1 = rep(0, 3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  binding = TRUE,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)
rm(list = c("upar", "lpar"))

prof4 %>% gt()
```



# `gridpts`
```{r gridpts_bm1}
r = 18
mu = 0
a = -Inf
b = Inf

# The same function as gridpts, but return a list instead of a tibble
gridptsls <- function(r = 18, mu = 0, a = -Inf, b = Inf){
  # Define odd numbered grid points for real line
  x <- c(mu - 3 - 4 * log(r / (1:(r - 1))),
         mu - 3 + 3 * (0:(4 * r)) / 2 / r,
         mu + 3 + 4 * log(r / (r - 1):1)
         )
  # Trim points outside of [a, b] and include those points
  if (min(x) < a) x <- c(a, x[x > a])
  if (max(x) > b) x <- c(x[x < b], b)
  # If extreme, include only 1 point where density will be essentially 0
  m <- length(x)
  if (m == 1) return(tibble::tibble(z=x, w=1))

  # Define even numbered grid points between the odd ones
  y <- (x[2:m] + x[1:(m-1)]) / 2

  # Compute weights for odd numbered grid points
  i <- 2:(m-1)
  wodd <- c(x[2] - x[1],
            (x[i + 1] - x[i - 1]),
            x[m] - x[m - 1]) / 6

  weven <- 4 * (x[2:m] - x[1:(m-1)]) / 6

  # Now combine odd- and even-numbered grid points with their
  # corresponding weights
  z <- rep(0, 2*m - 1)
  z[2 * (1:m) - 1] <- x
  z[2 * (1:(m-1))] <- y
  w <- z
  w[2 * (1:m) - 1] <- wodd
  w[2 * (1:(m-1))] <- weven

  return(list("z"=z, "w"=w))
}

mbm_gridpts <- microbenchmark(
  t0 = gridpts(r = r, mu = mu, a = a, b = b),
  t1 = gridptsls(r = r, mu = mu, a = a, b = b),
  t2 = gridptsRcpp(r = r, mu = mu, a = a, b = b),
  times = 1000
)
levels(mbm_gridpts$expr) <- c("gridpts", "gridptsls", "gridptsRcpp")
mbm_gridpts
```




```{r gridpts_bm2}
mbm_gridpts2 <- bench::mark(
  gridptsls(r = r, mu = mu, a = a, b = b),
  gridptsRcpp(r = r, mu = mu, a = a, b = b),
  iterations = 1000
)
mbm_gridpts2$expression[[1]] <- c("gridptsls")
mbm_gridpts2$expression[[2]] <- c("gridptsRcpp")
mbm_gridpts2
plot(mbm_gridpts2)
```


