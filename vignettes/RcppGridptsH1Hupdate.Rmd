---
title: "`gridpts`, `h1` and `hupdate` in Rcpp"
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(gsdmvn)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(bench)
library(microbenchmark)
devtools::load_all()
```

# `gridpts`, `h1` and `hupdate` in Rcpp

## `gridpts`
```{r gridpts_bm1}
r = 18
mu = 0
a = -Inf
b = Inf

# The same function as gridpts, but return a list instead of a tibble
gridptsls <- function(r = 18, mu = 0, a = -Inf, b = Inf){
  # Define odd numbered grid points for real line
  x <- c(mu - 3 - 4 * log(r / (1:(r - 1))),
         mu - 3 + 3 * (0:(4 * r)) / 2 / r,
         mu + 3 + 4 * log(r / (r - 1):1)
         )
  # Trim points outside of [a, b] and include those points
  if (min(x) < a) x <- c(a, x[x > a])
  if (max(x) > b) x <- c(x[x < b], b)
  # If extreme, include only 1 point where density will be essentially 0
  m <- length(x)
  if (m == 1) return(tibble::tibble(z=x, w=1))

  # Define even numbered grid points between the odd ones
  y <- (x[2:m] + x[1:(m-1)]) / 2

  # Compute weights for odd numbered grid points
  i <- 2:(m-1)
  wodd <- c(x[2] - x[1],
            (x[i + 1] - x[i - 1]),
            x[m] - x[m - 1]) / 6

  weven <- 4 * (x[2:m] - x[1:(m-1)]) / 6

  # Now combine odd- and even-numbered grid points with their
  # corresponding weights
  z <- rep(0, 2*m - 1)
  z[2 * (1:m) - 1] <- x
  z[2 * (1:(m-1))] <- y
  w <- z
  w[2 * (1:m) - 1] <- wodd
  w[2 * (1:(m-1))] <- weven

  return(list("z"=z, "w"=w))
}

mbm_gridpts <- microbenchmark(
  t0 = gridpts_(r = r, mu = mu, a = a, b = b),
  t1 = gridptsls(r = r, mu = mu, a = a, b = b),
  t2 = gridptsRcpp(r = r, mu = mu, a = a, b = b),
  times = 1000
)
levels(mbm_gridpts$expr) <- c("gridpts_", "gridptsls", "gridptsRcpp")
mbm_gridpts
```


```{r gridpts_bm2}
mbm_gridpts2 <- bench::mark(
  gridptsls(r = r, mu = mu, a = a, b = b),
  gridptsRcpp(r = r, mu = mu, a = a, b = b),
  iterations = 1000
)
mbm_gridpts2$expression[[1]] <- c("gridptsls")
mbm_gridpts2$expression[[2]] <- c("gridptsRcpp")
mbm_gridpts2
plot(mbm_gridpts2)
```

## `h1`
```{r h1_bm1}
r = 18
theta = 2
I = 1
a = -Inf
b= -.5

# The same function as h1, but return a list instead of a tibble
h1ls <- function(r = 18, theta = 0, I = 1, a = -Inf, b = Inf){
  # fix for binding message
  z <- w <- h <- NULL
  # compute drift at analysis 1
  mu <- theta * sqrt(I);
  g <- gridpts_(r, mu, a, b)
  # compute deviation from drift
  x <- g$z - mu
  # compute standard normal density, multiply by grid weight and return
  # values needed for numerical integration
  return(list("z" = g$z, "w" = g$w, "h" = g$w * dnorm(x)))
}

mbm_h1 <- microbenchmark(
  t0 = h1(r = r, theta = theta, I = I, a = a, b = b),
  t1 = h1ls(r = r, theta = theta, I = I, a = a, b = b),
  t2 = h1Rcpp(r = r, theta = theta, I = I, a = a, b = b),
  times = 1000
)
levels(mbm_h1$expr) <- c("h1", "h1ls", "h1Rcpp")
mbm_h1
```


```{r h1_bm2}
mbm_h12 <- bench::mark(
  h1ls(r = r, theta = theta, I = I, a = a, b = b),
  h1Rcpp(r = r, theta = theta, I = I, a = a, b = b),
  iterations = 1000
)
mbm_h12$expression[[1]] <- c("h1ls")
mbm_h12$expression[[2]] <- c("h1Rcpp")
mbm_h12
plot(mbm_h12)
```

## `hupdate`
```{r hupdate_bm1}
r = 18
theta = 2
I = 2
a = -Inf
b = 0
thetam1 = 2
Im1 = 1
gm1ls = h1Rcpp(r = 18, theta = 2, I = 1, a = -.5, b = 3)
gm1 = h1(r = 18, theta = 2, I = 1, a = -.5, b = 3)

# The same function as h1, but return a list instead of a tibble
hupdatels <- function(r = 18, theta = 0, I = 2, a = -Inf, b = Inf, thetam1 = 0, Im1 = 1, gm1 = h1()){
  # sqrt of change in information
  rtdelta <- sqrt(I - Im1)
  rtI <- sqrt(I)
  rtIm1 <- sqrt(Im1)
  g <- gridpts_(r = r, mu = theta * rtI, a= a, b = b)
  # update integration
  mu <- theta * I - thetam1 * Im1
  h <- rep(0, length(g$z))
  for(i in seq_along(g$z)){
    x <- (g$z[i] * rtI - gm1$z * rtIm1 - mu ) / rtdelta
    h[i] <- sum(gm1$h * dnorm(x))
  }
  h <- h * g$w * rtI / rtdelta
  return(list("z" = g$z, "w" = g$w, "h" = h))
}

mbm_hupdate <- microbenchmark(
  hupdate(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1),
  hupdatels(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  hupdateRcpp(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  times = 1000
)
levels(mbm_hupdate$expr) <- c("hupdate", "hupdatels", "hupdateRcpp")
mbm_hupdate
```


```{r hupdate_bm2}
mbm_hupdate2 <- bench::mark(
  hupdatels(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  hupdateRcpp(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  iterations = 1000
)
mbm_hupdate2$expression[[1]] <- c("hupdatels")
mbm_hupdate2$expression[[2]] <- c("hupdateRcpp")
mbm_hupdate2
plot(mbm_hupdate2)
```


# Improvements for `gs_power_npe`

```{r functions}
n_iter <- 100
prof_gs_power_npe <- function(times = rep(0, 6), n_iter = 100, runNew = FALSE,
                              upper_new=gs_b, lower_new=gs_b, 
    theta = .1, theta1 = NULL, info = 1, info1 = NULL, info0 = NULL,
                         binding = FALSE,
                         upper=gs_b, lower=gs_b, upar = qnorm(.975), lpar= -Inf,
                         test_upper = TRUE, test_lower = TRUE,
                         r = 18, tol = 1e-6){
  #######################################################################################
  # WRITE INPUT CHECK TESTS AND RETURN APPROPRIATE ERROR MESSAGES
  # theta should be a scalar or vector of real values; if vector, same length as info
  # info should be a scalar or vector of positive increasing values
  # info0 should be NULL or of the same form as info
  # test_upper and test_lower should be logical scalar or vector; if vector same length as info
  # END INPUT CHECKS
  #######################################################################################
  
for (itr in 1:n_iter) {
  # SET UP PARAMETERS
  #############Timer1############
  start1 <- Sys.time()

  K <- length(info)
  if (is.null(info0)) info0 <- info
  if (is.null(info1)) info1 <- info
  if (length(info1) != length(info) || length(info0) != length(info)) stop("gs_power_npe: length of info, info0, info1 must be the same")
  if (length(theta) == 1 && K > 1) theta <- rep(theta, K)
  if (is.null(theta1)){theta1 <- theta}else if (length(theta1)==1) theta1 <- rep(theta1,K)
  if (length(test_upper) == 1 && K > 1) test_upper <- rep(test_upper, K)
  if (length(test_lower) == 1 && K > 1) test_lower <- rep(test_lower, K)
  a <- rep(-Inf, K)
  b <- rep(Inf, K)
  hgm1_0 <- NULL
  hgm1_1 <- NULL
  hgm1 <- NULL
  upperProb <- rep(NA, K)
  lowerProb <- rep(NA, K)
  
  times[1] <- times[1] + difftime(Sys.time(), start1, units = "sec")[[1]]
  ######################################################################################
  # COMPUTE BOUNDS
  for(k in 1:K){
    #############Timer2############
    if (runNew) {
      start2 <- Sys.time()
      
      # Lower bound update
      a[k] <- lower_new(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                    efficacy = FALSE)
      # Upper bound update
      b[k] <- upper_new(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
      
      times[2] <- times[2] + difftime(Sys.time(), start2, units = "sec")[[1]]
    } else {
      start2 <- Sys.time()
      
      # Lower bound update
      a[k] <- lower(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                    efficacy = FALSE)
      # Upper bound update
      b[k] <- upper(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
      
      times[2] <- times[2] + difftime(Sys.time(), start2, units = "sec")[[1]]
    }
    ##############################
    if(k==1){
      #############Timer3############
      start3 <- Sys.time()
      
      upperProb[1] <- if(b[1] < Inf) {pnorm(b[1], mean = sqrt(info[1]) * theta[1], lower.tail = FALSE)}else{0}
      lowerProb[1] <- if(a[1] > -Inf){pnorm(a[1], mean = sqrt(info[1]) * theta[1])}else{0}

      times[3] <- times[3] + difftime(Sys.time(), start3, units = "sec")[[1]]
      #############Timer4###########
      if (runNew) {
      start4 <- Sys.time()

      hgm1_0 <- h1Rcpp(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- h1Rcpp(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- h1Rcpp(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
      
      times[4] <- times[4] + difftime(Sys.time(), start4, units = "sec")[[1]]
      } else {
      start4 <- Sys.time()

      hgm1_0 <- h1(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- h1(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- h1(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
      
      times[4] <- times[4] + difftime(Sys.time(), start4, units = "sec")[[1]]
      }
      ##############################
    }else{
      
      #############Timer5############
      if (runNew) {
        start5 <- Sys.time()
        # Cross upper bound
        upperProb[k] <- if(b[k]< Inf){
          # hupdate(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
          #         thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          #   summarise(sum(h)) %>% as.numeric()
          sum(hupdateRcpp(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                  thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1)$h)
        }else{0}
        # Cross lower bound
        lowerProb[k] <- if(a[k] > -Inf){
          # hupdate(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
          #         thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          #   summarise(sum(h)) %>% as.numeric()
          sum(hupdateRcpp(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                      thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1)$h)
        }else{0}
        if(k < K){
          # hgm1_0 <- hupdate(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
          #                   thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
          hgm1_0 <- hupdateRcpp(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                            thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
          # hgm1_1 <- hupdate(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
          #                   thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
          hgm1_1 <- hupdateRcpp(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                            thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
          # hgm1   <- hupdate(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
          #                   thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
          hgm1   <- hupdateRcpp(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                            thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
        }
        times[5] <- times[5] + difftime(Sys.time(), start5, units = "sec")[[1]]
      }else {
      start5 <- Sys.time()

      # Cross upper bound
      upperProb[k] <- if(b[k]< Inf){
        hupdate(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      # Cross lower bound
      lowerProb[k] <- if(a[k] > -Inf){
        hupdate(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      if(k < K){
        hgm1_0 <- hupdate(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                          thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
        hgm1_1 <- hupdate(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                          thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
        hgm1   <- hupdate(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                          thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
      }
      times[5] <- times[5] + difftime(Sys.time(), start5, units = "sec")[[1]]
      }
    }
  }
  
  ######################################################################################
  # RETURN A TIBBLE
  #############Timer6############
  start6 <- Sys.time()

  tibble::tibble(
    Analysis = rep(1:K, 2),
    Bound = c(rep("Upper", K), rep("Lower", K)),
    Z= c(b, a),
    Probability = c(cumsum(upperProb),
                    cumsum(lowerProb)),
    theta = rep(theta, 2),
    theta1 = rep(theta1, 2),
    info = rep(info, 2),
    info0 = rep(info0, 2),
    info1 = rep(info1, 2))
  times[6] <- times[6] + difftime(Sys.time(), start6, units = "sec")[[1]]

}
  tb <- data.frame(eval = c("Set up parameters",
                            "Compute bounds (including hupdate)",
                            "Compute probs",
                            "Compute gridpts (including h1)",
                            "Compute gridpts (including hupdate)",
                            "Create a tibble",
                            "All"),
                   time = round(c(times / n_iter, sum(times) / n_iter), 6),
                   percent = c(round(times / sum(times) * 100, 2), 100))
  if (runNew) {
    names(tb) <- c("eval", "new runtime in sec", "new %")
  } else {
    names(tb) <- c("eval", "runtime in sec", "%")
  }
  return (tb)
}
```

## Example 1: Single analysis with type I error controlled

### Runtime
```{r ex1_runtime}
mbm_ex1 <- bench::mark(
  gs_power_npe(theta = 0),
  gs_power_npe_new(theta = 0),
  iterations = 100
)
mbm_ex1$expression[[1]] <- c("gs_power_npe")
mbm_ex1$expression[[2]] <- c("gs_power_npe_new")
mbm_ex1
plot(mbm_ex1)
```

### Profile
```{r ex1_profile}
prof1 <- prof_gs_power_npe(theta = 0)
prof1_new <- prof_gs_power_npe(runNew = TRUE, theta = 0)
cbind(prof1, prof1_new[,2:3]) %>% gt()
```

## Example 2: Multiple analysis with fixed bound

### Runtime
```{r ex2_runtime}
upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
mbm_ex2 <- bench::mark(
  gs_power_npe(theta = c(.1, .2, .3),
    info = (1:3) * 40,
    upper = gs_b,
    upar = upar,
    lower = gs_b,
    lpar = c(-1, 0, 0)),
  gs_power_npe_new(theta = c(.1, .2, .3),
    info = (1:3) * 40,
    upper = gs_b,
    upar = upar,
    lower = gs_b,
    lpar = c(-1, 0, 0)),
  iterations = 100
)
mbm_ex2$expression[[1]] <- c("gs_power_npe")
mbm_ex2$expression[[2]] <- c("gs_power_npe_new")
mbm_ex2
plot(mbm_ex2)
```

### Profile
```{r ex2_profile}
upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
prof2 <- prof_gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = upar,
  lower = gs_b,
  lpar = c(-1, 0, 0))
rm(list = c("upar"))

upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
prof2_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = upar,
  lower = gs_b,
  lpar = c(-1, 0, 0))
rm(list = c("upar"))

cbind(prof2, prof2_new[,2:3]) %>% gt()
```

## Example 3: Multiple analysis with spending function bounds (2-sided asymmetric spend)

### Runtime
```{r ex3_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

mbm_ex3 <- bench::mark(
  gs_power_npe(
    theta = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  gs_power_npe_new(
    theta = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_new,
    upar = upar,
    lower = gs_spending_bound_new,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex3$expression[[1]] <- c("gs_power_npe")
mbm_ex3$expression[[2]] <- c("gs_power_npe_new")
mbm_ex3
plot(mbm_ex3)
```

### Profile
```{r ex3_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3 <- prof_gs_power_npe(
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)

prof3_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound_new,
  upar = upar,
  lower_new = gs_spending_bound_new,
  lpar = lpar)
rm(list = c("upar", "lpar"))

cbind(prof3, prof3_new[,2:3]) %>% gt()
```

### Same bounds, but power under different theta

#### Runtime
```{r ex31_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

mbm_ex3.1 <- bench::mark(
  gs_power_npe(
    theta = c(.15, .25, .35), 
    theta1 = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  gs_power_npe_new(
    theta = c(.15, .25, .35), 
    theta1 = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_new,
    upar = upar,
    lower = gs_spending_bound_new,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex3.1$expression[[1]] <- c("gs_power_npe")
mbm_ex3.1$expression[[2]] <- c("gs_power_npe_new")
mbm_ex3.1
plot(mbm_ex3.1)
```

#### Profile
```{r ex31_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3.1 <- prof_gs_power_npe(
  theta = c(.15, .25, .35), 
  theta1 = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)

prof3.1_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.15, .25, .35), 
  theta1 = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound_new,
  upar = upar,
  lower_new = gs_spending_bound_new,
  lpar = lpar)
rm(list = c("upar", "lpar"))

cbind(prof3.1, prof3.1_new[,2:3]) %>% gt()
```


## Example 4: Multiple analysis with spending function bounds (2-sided symmetric spend)

### Runtime
```{r ex4_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- upar

mbm_ex4 <- bench::mark(
  gs_power_npe(
    theta = rep(0, 3), 
    theta1 = rep(0, 3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    binding = TRUE,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  gs_power_npe_new(
    theta = rep(0, 3), 
    theta1 = rep(0, 3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_new,
    binding = TRUE,
    upar = upar,
    lower = gs_spending_bound_new,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex4$expression[[1]] <- c("gs_power_npe")
mbm_ex4$expression[[2]] <- c("gs_power_npe_new")
mbm_ex4
plot(mbm_ex4)
```

### Profile
```{r ex4_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- upar

prof4 <- prof_gs_power_npe(
  theta = rep(0, 3), 
  theta1 = rep(0, 3), 
  info = (1:3) * 40,
  upper = gs_spending_bound,
  binding = TRUE,
  upar = upar,
  lower = gs_spending_bound,
  lpar = lpar)

prof4_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = rep(0, 3), 
  theta1 = rep(0, 3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound_new,
  binding = TRUE,
  upar = upar,
  lower_new = gs_spending_bound_new,
  lpar = lpar)

rm(list = c("upar", "lpar"))

cbind(prof4, prof4_new[,2:3]) %>% gt()
```

