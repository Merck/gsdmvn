---
title: "Info_scale in `gs_power_npe`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 2
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(gsDesign)
library(dplyr)
library(gt)
devtools::load_all()
```

# Default 
The default is a single analysis with type I error controlled:
- `theta` = ``theta1` = 0.1
- `info` = `info1` = `info0` = 1
- `info_scale` = 2
- upper bound is `qnorm(.975)`
- lower bound is `-Inf` and it is non-binding.
```{r}
gs_power_npe() %>% gt()
```

If we use `info_scale = 0`, then we will use the null hypothesis for all calculations.
```{r}
gs_power_npe(info_scale = 0) %>% gt()
```

Besides, if we use `info_scale = 1`, then we will use the alternative hypothesis for all calculations.
```{r}
gs_power_npe(info_scale = 1) %>% gt()
```

In this case, since `info` = `info1` = `info0`, so the above 3 outputs are the same.

# Fixed bound

In the following example, we investigate a design with 3 analysis. 
The upper boundary is fixed and calculated from `gsDesign`.


## Fixed bound with futility bounds
The lower boundary is `(-1, 0, 0)`.

If we use `info_scale = 2`, i.e., do calculations as currently specified `info`.
```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40, 
  info0 = (1:3) * 40,
  info_scale = 2,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lower = gs_b, 
  lpar = c(-1, 0, 0)) %>% gt()
```

For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.
If the `info`, `info0`, `info1` is different, then the calculation of `info_scale = 0, 1, 2`will be different.

```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40, 
  info0 = (1:3) * 30,
  info1 = (1:3) * 50,
  info_scale = 2,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lower = gs_b, 
  lpar = c(-1, 0, 0)) %>% gt()
```

```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40, 
  info0 = (1:3) * 30,
  info1 = (1:3) * 50,
  info_scale = 1,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lower = gs_b, 
  lpar = c(-1, 0, 0)) %>% gt()
```

```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40, 
  info0 = (1:3) * 30,
  info1 = (1:3) * 50,
  info_scale = 0,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lower = gs_b, 
  lpar = c(-1, 0, 0)) %>% gt()
```

# Fixed bound without futility bounds under null hypothesis

In this example, we use the same fixed efficacy bounds as the last example.
But there will be no futility bound (i.e., non-binding bound).

```{r}
gs_power_npe(
  theta = rep(0, 3),
  info = (1:3) * 40,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,
  lpar = rep(-Inf, 3)
  ) %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.

# Fixed bound with futility only at analysis 1 and efficacy only at analyses 2, 3
```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upar = c(Inf, 3, 2),
  lpar = c(qnorm(.1), -Inf, -Inf)) %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.

# Spending function bounds

## Lower spending based on non-zero effect
```{r}
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.

## Same bounds, but power under different theta
```{r}
gs_power_npe(
  theta = c(.15, .25, .35),
  theta1 = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.


# Two-sided symmetric spend, O'Brien-Fleming spending

## Typically, 2-sided bounds are binding
```{r}
x <- gs_power_npe(
  theta = rep(0, 3),
  theta1 = rep(0, 3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))

x %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.

## Re-use these bounds under alternate hypothesis
Always use `binding = TRUE` for power calculations
```{r}
gs_power_npe(
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  binding = TRUE,
  upar = (x %>% filter(Bound=="Upper"))$Z,
  lpar = -(x %>% filter(Bound=="Upper"))$Z) %>% gt()
```
For `info_scale = 0` and `info_scale = 1`, they gives the same results given the same `info`, `info0`, `info1`.

