---
title: "`gridpts`, `h1` and `hupdate` in Rcpp"
author: "Jianxiao Yang"
output:
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
    number_sections: true
vignette: |
  %\VignetteIndexEntry{`gridpts`, `h1` and `hupdate` in Rcpp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
sessionInfo()
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(gsdmvn)
library(knitr)
library(tibble)
library(dplyr)
library(gt)
library(ggplot2)
library(bench)
library(microbenchmark)
```

# `gridpts`, `h1` and `hupdate` in Rcpp

## `gridpts`
```{r gridpts_bm1}
r = 18
mu = 0
a = -Inf
b = Inf

# The same function as gridpts, but return a list instead of a tibble
gridptsls <- function(r = 18, mu = 0, a = -Inf, b = Inf){
  # Define odd numbered grid points for real line
  x <- c(mu - 3 - 4 * log(r / (1:(r - 1))),
         mu - 3 + 3 * (0:(4 * r)) / 2 / r,
         mu + 3 + 4 * log(r / (r - 1):1)
         )
  # Trim points outside of [a, b] and include those points
  if (min(x) < a) x <- c(a, x[x > a])
  if (max(x) > b) x <- c(x[x < b], b)
  # If extreme, include only 1 point where density will be essentially 0
  m <- length(x)
  if (m == 1) return(tibble::tibble(z=x, w=1))

  # Define even numbered grid points between the odd ones
  y <- (x[2:m] + x[1:(m-1)]) / 2

  # Compute weights for odd numbered grid points
  i <- 2:(m-1)
  wodd <- c(x[2] - x[1],
            (x[i + 1] - x[i - 1]),
            x[m] - x[m - 1]) / 6

  weven <- 4 * (x[2:m] - x[1:(m-1)]) / 6

  # Now combine odd- and even-numbered grid points with their
  # corresponding weights
  z <- rep(0, 2*m - 1)
  z[2 * (1:m) - 1] <- x
  z[2 * (1:(m-1))] <- y
  w <- z
  w[2 * (1:m) - 1] <- wodd
  w[2 * (1:(m-1))] <- weven

  return(list("z"=z, "w"=w))
}

mbm_gridpts <- microbenchmark(
  t0 = gsdmvn:::gridpts_(r = r, mu = mu, a = a, b = b),
  t1 = gridptsls(r = r, mu = mu, a = a, b = b),
  t2 = gridpts(r = r, mu = mu, a = a, b = b),
  times = 1000
)
levels(mbm_gridpts$expr) <- c("old gridpts", "old gridpts returning list", "new gridpts")
mbm_gridpts
```


```{r gridpts_bm2}
mbm_gridpts2 <- bench::mark(
  gridptsls(r = r, mu = mu, a = a, b = b),
  gridpts(r = r, mu = mu, a = a, b = b),
  iterations = 1000
)
mbm_gridpts2$expression[[1]] <- c("old gridpts returning list")
mbm_gridpts2$expression[[2]] <- c("new gridpts")
mbm_gridpts2
plot(mbm_gridpts2)
```

## `h1`
```{r h1_bm1}
r = 18
theta = 2
I = 1
a = -Inf
b= -.5

# The same function as h1, but return a list instead of a tibble
h1ls <- function(r = 18, theta = 0, I = 1, a = -Inf, b = Inf){
  # fix for binding message
  z <- w <- h <- NULL
  # compute drift at analysis 1
  mu <- theta * sqrt(I);
  g <- gsdmvn:::gridpts_(r, mu, a, b)
  # compute deviation from drift
  x <- g$z - mu
  # compute standard normal density, multiply by grid weight and return
  # values needed for numerical integration
  return(list("z" = g$z, "w" = g$w, "h" = g$w * dnorm(x)))
}

mbm_h1 <- microbenchmark(
  t0 = gsdmvn:::h1_(r = r, theta = theta, I = I, a = a, b = b),
  t1 = h1ls(r = r, theta = theta, I = I, a = a, b = b),
  t2 = h1(r = r, theta = theta, I = I, a = a, b = b),
  times = 1000
)
levels(mbm_h1$expr) <- c("old h1", "old h1 returning ls", "new h1")
mbm_h1
```


```{r h1_bm2}
mbm_h12 <- bench::mark(
  h1ls(r = r, theta = theta, I = I, a = a, b = b),
  h1(r = r, theta = theta, I = I, a = a, b = b),
  iterations = 1000
)
mbm_h12$expression[[1]] <- c("old h1 returning list")
mbm_h12$expression[[2]] <- c("new h1")
mbm_h12
plot(mbm_h12)
```

## `hupdate`
```{r hupdate_bm1}
r = 18
theta = 2
I = 2
a = -Inf
b = 0
thetam1 = 2
Im1 = 1
gm1ls = h1(r = 18, theta = 2, I = 1, a = -.5, b = 3)
gm1 = gsdmvn:::h1_(r = 18, theta = 2, I = 1, a = -.5, b = 3)

# The same function as h1, but return a list instead of a tibble
hupdatels <- function(r = 18, theta = 0, I = 2, a = -Inf, b = Inf, thetam1 = 0, Im1 = 1, gm1 = h1()){
  # sqrt of change in information
  rtdelta <- sqrt(I - Im1)
  rtI <- sqrt(I)
  rtIm1 <- sqrt(Im1)
  g <- gsdmvn:::gridpts_(r = r, mu = theta * rtI, a= a, b = b)
  # update integration
  mu <- theta * I - thetam1 * Im1
  h <- rep(0, length(g$z))
  for(i in seq_along(g$z)){
    x <- (g$z[i] * rtI - gm1$z * rtIm1 - mu ) / rtdelta
    h[i] <- sum(gm1$h * dnorm(x))
  }
  h <- h * g$w * rtI / rtdelta
  return(list("z" = g$z, "w" = g$w, "h" = h))
}

mbm_hupdate <- microbenchmark(
  gsdmvn:::hupdate_(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1),
  hupdatels(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  hupdate(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  times = 1000
)
levels(mbm_hupdate$expr) <- c("old hupdate", "old hupdate returning list", "new hupdate")
mbm_hupdate
```


```{r hupdate_bm2}
mbm_hupdate2 <- bench::mark(
  hupdatels(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  hupdate(r = r, theta = theta, I = I, a = a, b = b, thetam1 = thetam1, Im1 = Im1, gm1 = gm1ls),
  iterations = 1000
)
mbm_hupdate2$expression[[1]] <- c("old hupdate returning list")
mbm_hupdate2$expression[[2]] <- c("new hupdate")
mbm_hupdate2
plot(mbm_hupdate2)
```


# Improvements for `gs_power_npe`

```{r functions}
n_iter <- 100

## old gs_power_npe
gs_power_npe_ <- function(theta = .1, theta1 = NULL, info = 1, info1 = NULL, info0 = NULL,
                         binding = FALSE,
                         upper=gs_b, lower=gs_b, upar = qnorm(.975), lpar= -Inf,
                         test_upper = TRUE, test_lower = TRUE,
                         r = 18, tol = 1e-6){
  #######################################################################################
  # WRITE INPUT CHECK TESTS AND RETURN APPROPRIATE ERROR MESSAGES
  # theta should be a scalar or vector of real values; if vector, same length as info
  # info should be a scalar or vector of positive increasing values
  # info0 should be NULL or of the same form as info
  # test_upper and test_lower should be logical scalar or vector; if vector same length as info
  # END INPUT CHECKS
  #######################################################################################
  # SET UP PARAMETERS
  K <- length(info)
  if (is.null(info0)) info0 <- info
  if (is.null(info1)) info1 <- info
  if (length(info1) != length(info) || length(info0) != length(info)) stop("gs_power_npe: length of info, info0, info1 must be the same")
  if (length(theta) == 1 && K > 1) theta <- rep(theta, K)
  if (is.null(theta1)){theta1 <- theta}else if (length(theta1)==1) theta1 <- rep(theta1,K)
  if (length(test_upper) == 1 && K > 1) test_upper <- rep(test_upper, K)
  if (length(test_lower) == 1 && K > 1) test_lower <- rep(test_lower, K)
  a <- rep(-Inf, K)
  b <- rep(Inf, K)
  hgm1_0 <- NULL
  hgm1_1 <- NULL
  hgm1 <- NULL
  upperProb <- rep(NA, K)
  lowerProb <- rep(NA, K)
  ######################################################################################
  # COMPUTE BOUNDS
  for(k in 1:K){
    # Lower bound update
    a[k] <- lower(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                  efficacy = FALSE)
    # Upper bound update
    b[k] <- upper(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
    if(k==1){
      upperProb[1] <- if(b[1] < Inf) {pnorm(b[1], mean = sqrt(info[1]) * theta[1], lower.tail = FALSE)}else{0}
      lowerProb[1] <- if(a[1] > -Inf){pnorm(a[1], mean = sqrt(info[1]) * theta[1])}else{0}
      hgm1_0 <- gsdmvn:::h1_(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- gsdmvn:::h1_(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- gsdmvn:::h1_(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
    }else{
      # Cross upper bound
      upperProb[k] <- if(b[k]< Inf){
        gsdmvn:::hupdate_(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      # Cross lower bound
      lowerProb[k] <- if(a[k] > -Inf){
        gsdmvn:::hupdate_(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      if(k < K){
        hgm1_0 <- gsdmvn:::hupdate_(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                          thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
        hgm1_1 <- gsdmvn:::hupdate_(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                          thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
        hgm1   <- gsdmvn:::hupdate_(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                          thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
      }
    }
  }
  return(tibble::tibble(
    Analysis = rep(1:K, 2),
    Bound = c(rep("Upper", K), rep("Lower", K)),
    Z= c(b, a),
    Probability = c(cumsum(upperProb),
                    cumsum(lowerProb)),
    theta = rep(theta, 2),
    theta1 = rep(theta1, 2),
    info = rep(info, 2),
    info0 = rep(info0, 2),
    info1 = rep(info1, 2))
  )
}

## old gs_spending_bound_
gs_spending_bound_ <- function(k = 1,
                              par = list(sf = gsDesign::sfLDOF,
                                              total_spend = 0.025,
                                              param = NULL,
                                              timing = NULL,
                                              max_info = NULL
                                         ),
                              hgm1 = NULL,
                              theta = .1,
                              info = 1:3,
                              efficacy = TRUE,
                              test_bound = TRUE,
                              r = 18,
                              tol = 1e-6){
  # Set spending time at analyses
  if (!is.null(par$timing)){ timing <- par$timing
  }else{
    if (is.null(par$max_info)){
         timing <- info / (max(info))
    }else timing <- info / par$max_info
  }
  # Cumulative spending at analyses
  spend <- par$sf(alpha = par$total_spend, t = timing, param = par$param)$spend
  # Get incremental spend at each analysis
  old_spend <- 0
  # Make test_bound a vector of length k > 1 if input as a single value
  if (length(test_bound) == 1 && k > 1) test_bound <- rep(test_bound, k)
  # Get incremental spend at each analysis
  for(i in 1:k){
    if (test_bound[i]){ # Check if spending is taken at analysis i
      xx <- spend[i] - old_spend # Cumulative spending minus previous spending
      old_spend <- spend[i] # Reset previous spending
      spend[i] <- xx # Incremental spend at analysis i
    }else spend[i] <- 0 # 0 incremental spend if no testing at analysis i
  }
  # Now just get spending for current bound
  spend <- spend[k]
  # lower bound
  if (!efficacy){
    if (spend <= 0) return(-Inf) # If no spending, return -Inf for bound
    # if theta not a vector, make it one
    if (length(theta) == 1) theta <- rep(theta, length(info))
    # Starting value
    a <- qnorm(spend) + sqrt(info[k]) * theta[k]
    if (k == 1) return(a) # No need for iteration for first interim
    # Extremes for numerical integration
    mu <- theta[k] * sqrt(info[k])
    EXTREMElow <- mu - 3 - 4 * log(r)
    EXTREMEhi <- mu + 3 + 4 * log(r)
    # iterate to convergence as in gsbound.c from gsDesign
    adelta <- 1
    j <- 0
    while(abs(adelta) > tol)
    {  # Get grid for rejection region
      hg <- gsdmvn:::hupdate_(theta = theta[k], I =  info[k], a = -Inf, b = a, thetam1 = theta[k-1], Im1 = info[k-1], gm1 = hgm1, r = r)
      i <- nrow(hg)
      pik <- hg %>% summarise(sum(h)) %>% as.numeric() # pik is for lower bound crossing

      # FOLLOWING UPDATE ALGORITHM FROM GSDESIGN::GSBOUND.C
      ##################################################################
      # use 1st order Taylor's series to update boundaries
      # maximum allowed change is 1
      # maximum value allowed is z1[m1]*rtIk to keep within grid points
      adelta <- spend - pik
      dplo <- hg$h[i] / hg$w[i]
      if (adelta > dplo){adelta <- 1
      }else if (adelta < -dplo){adelta <- -1
      }else adelta <- adelta / dplo
      a <- a + adelta
      if (a > EXTREMEhi){a <- EXTREMEhi
      }else if (a < EXTREMElow) a <- EXTREMElow
      #################################################################

      if (abs(adelta) < tol) return(a)
      j <- j + 1
      if (j > 20) stop(paste("gs_spending_bound(): bound_update did not converge for lower bound calculation, analysis", k))
    }
}else{
    # upper bound
    if(spend <= 0) return(Inf)
    # Starting value
    b <- qnorm(spend, lower.tail = FALSE)
    if(k == 1) return(b) # No iteration needed for first bound
    for(iter in 0:20){
      # subdensity for final analysis in rejection region
      hg <- gsdmvn:::hupdate_(theta = 0, I =  info[k], a = b, b = Inf, thetam1 = 0, Im1 = info[k-1], gm1 = hgm1)
      pik <- as.numeric(hg %>% summarise(sum(h))) # Probability of crossing bound
      dpikdb <- hg$h[1] / hg$w[1] # Derivative of bound crossing at b[k]
      b_old <- b
      b <- b - (spend - pik) / dpikdb # Newton-Raphson update
      if (abs(b - b_old) < tol) return(b)
    }
    stop(paste("gs_spending_bound(): bound_update did not converge for upper bound calculation, analysis", k))
  }
}

## profile function
prof_gs_power_npe <- function(times = rep(0, 6), n_iter = 100, runNew = FALSE,
                              upper_new=gs_b, lower_new=gs_b, 
    theta = .1, theta1 = NULL, info = 1, info1 = NULL, info0 = NULL,
                         binding = FALSE,
                         upper=gs_b, lower=gs_b, upar = qnorm(.975), lpar= -Inf,
                         test_upper = TRUE, test_lower = TRUE,
                         r = 18, tol = 1e-6){
  #######################################################################################
  # WRITE INPUT CHECK TESTS AND RETURN APPROPRIATE ERROR MESSAGES
  # theta should be a scalar or vector of real values; if vector, same length as info
  # info should be a scalar or vector of positive increasing values
  # info0 should be NULL or of the same form as info
  # test_upper and test_lower should be logical scalar or vector; if vector same length as info
  # END INPUT CHECKS
  #######################################################################################
  
for (itr in 1:n_iter) {
  # SET UP PARAMETERS
  #############Timer1############
  start1 <- Sys.time()

  K <- length(info)
  if (is.null(info0)) info0 <- info
  if (is.null(info1)) info1 <- info
  if (length(info1) != length(info) || length(info0) != length(info)) stop("gs_power_npe: length of info, info0, info1 must be the same")
  if (length(theta) == 1 && K > 1) theta <- rep(theta, K)
  if (is.null(theta1)){theta1 <- theta}else if (length(theta1)==1) theta1 <- rep(theta1,K)
  if (length(test_upper) == 1 && K > 1) test_upper <- rep(test_upper, K)
  if (length(test_lower) == 1 && K > 1) test_lower <- rep(test_lower, K)
  a <- rep(-Inf, K)
  b <- rep(Inf, K)
  hgm1_0 <- NULL
  hgm1_1 <- NULL
  hgm1 <- NULL
  upperProb <- rep(NA, K)
  lowerProb <- rep(NA, K)
  
  times[1] <- times[1] + difftime(Sys.time(), start1, units = "sec")[[1]]
  ######################################################################################
  # COMPUTE BOUNDS
  for(k in 1:K){
    #############Timer2############
    if (runNew) {
      start2 <- Sys.time()
      
      # Lower bound update
      a[k] <- lower_new(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                    efficacy = FALSE)
      # Upper bound update
      b[k] <- upper_new(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
      
      times[2] <- times[2] + difftime(Sys.time(), start2, units = "sec")[[1]]
    } else {
      start2 <- Sys.time()
      
      # Lower bound update
      a[k] <- lower(k = k, par = lpar, hgm1 = hgm1_1, theta = theta1, info = info1, r = r, tol = tol, test_bound = test_lower,
                    efficacy = FALSE)
      # Upper bound update
      b[k] <- upper(k = k, par = upar, hgm1 = hgm1_0, info = info0, r = r, tol = tol, test_bound = test_upper)
      
      times[2] <- times[2] + difftime(Sys.time(), start2, units = "sec")[[1]]
    }
    ##############################
    if(k==1){
      #############Timer3############
      start3 <- Sys.time()
      
      upperProb[1] <- if(b[1] < Inf) {pnorm(b[1], mean = sqrt(info[1]) * theta[1], lower.tail = FALSE)}else{0}
      lowerProb[1] <- if(a[1] > -Inf){pnorm(a[1], mean = sqrt(info[1]) * theta[1])}else{0}

      times[3] <- times[3] + difftime(Sys.time(), start3, units = "sec")[[1]]
      #############Timer4###########
      if (runNew) {
      start4 <- Sys.time()

      hgm1_0 <- h1(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- h1(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- h1(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
      
      times[4] <- times[4] + difftime(Sys.time(), start4, units = "sec")[[1]]
      } else {
      start4 <- Sys.time()

      hgm1_0 <- gsdmvn:::h1_(r = r, theta = 0,         I = info0[1], a = if(binding){a[1]}else{-Inf}, b = b[1])
      hgm1_1 <- gsdmvn:::h1_(r = r, theta = theta1[1], I = info1[1], a = a[1], b = b[1])
      hgm1   <- gsdmvn:::h1_(r = r, theta = theta[1],  I = info[1],  a = a[1], b = b[1])
      
      times[4] <- times[4] + difftime(Sys.time(), start4, units = "sec")[[1]]
      }
      ##############################
    }else{
      
      #############Timer5############
      if (runNew) {
        start5 <- Sys.time()
        # Cross upper bound
        upperProb[k] <- if(b[k]< Inf){
          # hupdate(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
          #         thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          #   summarise(sum(h)) %>% as.numeric()
          sum(hupdate(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                  thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1)$h)
        }else{0}
        # Cross lower bound
        lowerProb[k] <- if(a[k] > -Inf){
          # hupdate(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
          #         thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          #   summarise(sum(h)) %>% as.numeric()
          sum(hupdate(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                      thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1)$h)
        }else{0}
        if(k < K){
          # hgm1_0 <- hupdate(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
          #                   thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
          hgm1_0 <- hupdate(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                            thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
          # hgm1_1 <- hupdate(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
          #                   thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
          hgm1_1 <- hupdate(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                            thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
          # hgm1   <- hupdate(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
          #                   thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
          hgm1   <- hupdate(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                            thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
        }
        times[5] <- times[5] + difftime(Sys.time(), start5, units = "sec")[[1]]
      }else {
      start5 <- Sys.time()

      # Cross upper bound
      upperProb[k] <- if(b[k]< Inf){
        gsdmvn:::hupdate_(r = r, theta = theta[k], I = info[k], a = b[k], b = Inf,
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      # Cross lower bound
      lowerProb[k] <- if(a[k] > -Inf){
        gsdmvn:::hupdate_(r = r, theta = theta[k], I = info[k], a = -Inf, b = a[k],
                thetam1 = theta[k - 1], Im1 = info[k - 1], gm1 = hgm1) %>%
          summarise(sum(h)) %>% as.numeric()
      }else{0}
      if(k < K){
        hgm1_0 <- gsdmvn:::hupdate_(r = r, theta = 0,         I = info0[k], a = if(binding){a[k]}else{-Inf}, b = b[k],
                          thetam1 = 0,           Im1 = info0[k-1], gm1 = hgm1_0)
        hgm1_1 <- gsdmvn:::hupdate_(r = r, theta = theta1[k], I = info1[k], a = a[k], b = b[k],
                          thetam1 = theta1[k-1], Im1 = info1[k-1], gm1 = hgm1_1)
        hgm1   <- gsdmvn:::hupdate_(r = r, theta = theta[k],  I = info[k],  a = a[k], b = b[k],
                          thetam1 = theta[k-1],  Im1 = info[k-1],  gm1 = hgm1)
      }
      times[5] <- times[5] + difftime(Sys.time(), start5, units = "sec")[[1]]
      }
    }
  }
  
  ######################################################################################
  # RETURN A TIBBLE
  #############Timer6############
  start6 <- Sys.time()

  tibble::tibble(
    Analysis = rep(1:K, 2),
    Bound = c(rep("Upper", K), rep("Lower", K)),
    Z= c(b, a),
    Probability = c(cumsum(upperProb),
                    cumsum(lowerProb)),
    theta = rep(theta, 2),
    theta1 = rep(theta1, 2),
    info = rep(info, 2),
    info0 = rep(info0, 2),
    info1 = rep(info1, 2))
  times[6] <- times[6] + difftime(Sys.time(), start6, units = "sec")[[1]]

}
  tb <- data.frame(eval = c("Set up parameters",
                            "Compute bounds (including hupdate)",
                            "Compute probs",
                            "Compute gridpts (including h1)",
                            "Compute gridpts (including hupdate)",
                            "Create a tibble",
                            "All"),
                   time = round(c(times / n_iter, sum(times) / n_iter), 6),
                   percent = c(round(times / sum(times) * 100, 2), 100))
  if (runNew) {
    names(tb) <- c("eval", "new runtime in sec", "new %")
  } else {
    names(tb) <- c("eval", "old runtime in sec", "old %")
  }
  return (tb)
}
```

## Example 1: Single analysis with type I error controlled

### Runtime
```{r ex1_runtime}
mbm_ex1 <- bench::mark(
  gs_power_npe_(theta = 0),
  gs_power_npe(theta = 0),
  iterations = 100
)
mbm_ex1$expression[[1]] <- c("old gs_power_npe")
mbm_ex1$expression[[2]] <- c("new gs_power_npe")
mbm_ex1
# plot(mbm_ex1)
```

### Profile
```{r ex1_profile}
prof1 <- prof_gs_power_npe(theta = 0)
prof1_new <- prof_gs_power_npe(runNew = TRUE, theta = 0)
cbind(prof1, prof1_new[,2:3]) %>% gt()
```

## Example 2: Multiple analysis with fixed bound

### Runtime
```{r ex2_runtime}
upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
mbm_ex2 <- bench::mark(
  gs_power_npe_(theta = c(.1, .2, .3),
    info = (1:3) * 40,
    upper = gs_b,
    upar = upar,
    lower = gs_b,
    lpar = c(-1, 0, 0)),
  gs_power_npe(theta = c(.1, .2, .3),
    info = (1:3) * 40,
    upper = gs_b,
    upar = upar,
    lower = gs_b,
    lpar = c(-1, 0, 0)),
  iterations = 100
)
mbm_ex2$expression[[1]] <- c("old gs_power_npe")
mbm_ex2$expression[[2]] <- c("new gs_power_npe")
mbm_ex2
# plot(mbm_ex2)
```

### Profile
```{r ex2_profile}
upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
prof2 <- prof_gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = upar,
  lower = gs_b,
  lpar = c(-1, 0, 0))
rm(list = c("upar"))

upar <- gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound
prof2_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  upper = gs_b,
  upar = upar,
  lower = gs_b,
  lpar = c(-1, 0, 0))
rm(list = c("upar"))

cbind(prof2, prof2_new[,2:3]) %>% gt()
```

## Example 3: Multiple analysis with spending function bounds (2-sided asymmetric spend)

### Runtime
```{r ex3_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

mbm_ex3 <- bench::mark(
  gs_power_npe_(
    theta = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_,
    upar = upar,
    lower = gs_spending_bound_,
    lpar = lpar
  ),
  gs_power_npe(
    theta = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex3$expression[[1]] <- c("old gs_power_npe")
mbm_ex3$expression[[2]] <- c("new gs_power_npe")
mbm_ex3
# plot(mbm_ex3)
```

### Profile
```{r ex3_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3 <- prof_gs_power_npe(
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound_,
  upar = upar,
  lower = gs_spending_bound_,
  lpar = lpar)

prof3_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound,
  upar = upar,
  lower_new = gs_spending_bound,
  lpar = lpar)
rm(list = c("upar", "lpar"))

cbind(prof3, prof3_new[,2:3]) %>% gt()
```

### Same bounds, but power under different theta

#### Runtime
```{r ex31_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

mbm_ex3.1 <- bench::mark(
  gs_power_npe_(
    theta = c(.15, .25, .35), 
    theta1 = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_,
    upar = upar,
    lower = gs_spending_bound_,
    lpar = lpar
  ),
  gs_power_npe(
    theta = c(.15, .25, .35), 
    theta1 = c(.1, .2, .3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex3.1$expression[[1]] <- c("old gs_power_npe")
mbm_ex3.1$expression[[2]] <- c("new gs_power_npe")
mbm_ex3.1
# plot(mbm_ex3.1)
```

#### Profile
```{r ex31_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)

prof3.1 <- prof_gs_power_npe(
  theta = c(.15, .25, .35), 
  theta1 = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper = gs_spending_bound_,
  upar = upar,
  lower = gs_spending_bound_,
  lpar = lpar)

prof3.1_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = c(.15, .25, .35), 
  theta1 = c(.1, .2, .3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound,
  upar = upar,
  lower_new = gs_spending_bound,
  lpar = lpar)
rm(list = c("upar", "lpar"))

cbind(prof3.1, prof3.1_new[,2:3]) %>% gt()
```


## Example 4: Multiple analysis with spending function bounds (2-sided symmetric spend)

### Runtime
```{r ex4_runtime}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- upar

mbm_ex4 <- bench::mark(
  gs_power_npe_(
    theta = rep(0, 3), 
    theta1 = rep(0, 3), 
    info = (1:3) * 40,
    upper = gs_spending_bound_,
    binding = TRUE,
    upar = upar,
    lower = gs_spending_bound_,
    lpar = lpar
  ),
  gs_power_npe(
    theta = rep(0, 3), 
    theta1 = rep(0, 3), 
    info = (1:3) * 40,
    upper = gs_spending_bound,
    binding = TRUE,
    upar = upar,
    lower = gs_spending_bound,
    lpar = lpar
  ),
  iterations = 100
)
rm(list = c("upar", "lpar"))
mbm_ex4$expression[[1]] <- c("old gs_power_npe")
mbm_ex4$expression[[2]] <- c("new gs_power_npe")
mbm_ex4
# plot(mbm_ex4)
```

### Profile
```{r ex4_profile}
upar <- list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
lpar <- upar

prof4 <- prof_gs_power_npe(
  theta = rep(0, 3), 
  theta1 = rep(0, 3), 
  info = (1:3) * 40,
  upper = gs_spending_bound_,
  binding = TRUE,
  upar = upar,
  lower = gs_spending_bound_,
  lpar = lpar)

prof4_new <- prof_gs_power_npe(
  runNew = TRUE,
  theta = rep(0, 3), 
  theta1 = rep(0, 3), 
  info = (1:3) * 40,
  upper_new = gs_spending_bound,
  binding = TRUE,
  upar = upar,
  lower_new = gs_spending_bound,
  lpar = lpar)

rm(list = c("upar", "lpar"))

cbind(prof4, prof4_new[,2:3]) %>% gt()
```

